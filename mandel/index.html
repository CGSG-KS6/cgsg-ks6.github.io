<html>

<head>
  <title>Fractal</title>

  <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

  <script id="shader-fs" type="x-shader/x-fragment">
    precision highp float;

    uniform float zoom;
    uniform vec2 resolution;
    uniform vec2 offset;
    uniform int iterations;

    float GetMandelbrot(vec2 pos, float zoom, vec2 offset)
    {
      vec2 C = offset + pos / zoom;                
      vec2 Zn=vec2(0.0, 0.0);

      for( int i = 0; i < 1000; ++i)
      {
        if (i >= iterations) break;

        float x2 = Zn.x * Zn.x;
        float y2 = Zn.y * Zn.y;
        if (x2 + y2 > 4.0)
        { 
          return float(i + 1) / float(iterations + 1);
        } 
        
        Zn.y = (Zn.y * Zn.x * 2.0) + C.y; 
        Zn.x = (x2 - y2) + C.x; 
      }
      return 0.0;
    }
        
    void main( void ) 
    {
      float aspectRatio = resolution.x / resolution.y;
      vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
      position.x *= aspectRatio;

      gl_FragColor = vec4(0.0,0.0,0.0,0.0);

      float scale = GetMandelbrot(position, zoom, offset);
      if (scale == 0.0)
        gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
      else
        gl_FragColor = vec4( 0.6, 0.8, 1.0, 0.0 ) * scale + vec4(0.0, 0.2, 0.4, 1.0);
    }
  </script>

  <script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    void main(void)
    {
      gl_Position = vec4(aVertexPosition, 1.0);
    }
  </script>

  <script type="text/javascript">
    var
      gl,
      canvas,
      checkers_cell_width,
      shaderProgram,
      fractalZoom,
      iterationsCount,
      mouseDragX,
      mouseDragY,
      mouseDragging,
      oldMouseX,
      oldMouseY,
      is_shader_loaded;

    function initGL(canvas) {
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {
      }
      if (!gl) {
        alert("Could not initialise WebGL");
      }

      mvMatrix = mat4.create();
      pMatrix = mat4.create();
    }

    function createShader(shader_path, shader_type) {
      return new Promise(function (resolve, reject) {
        let shd;

        window.fetch(shader_path)
          .then((response) => {
            return response.text();
          })
          .then((file_text) => {
            if (shader_type == "fragment")
              shd = gl.createShader(gl.FRAGMENT_SHADER);
            else if (shader_type == "vertex")
              shd = gl.createShader(gl.VERTEX_SHADER);
            else
              reject(shd); //shd type error

            gl.shaderSource(shd, file_text);
            gl.compileShader(shd);

            if (!gl.getShaderParameter(shd, gl.COMPILE_STATUS)) {
              alert("ERROR.\n" + "SHADER TYPE: " + shaderScript.type + "\n\n" + gl.getShaderInfoLog(shd));
              reject(shd);
            }

            resolve(shd);
          });
      });
    }

    function initShaders() {
      let shaders_info =
        [
          { Path: 'shaders/vertex.glsl', Type: "vertex" },
          { Path: 'shaders/fragment.glsl', Type: "fragment" }
        ];

      let creation_requests = shaders_info.map(shader_info => createShader(shader_info.Path, shader_info.Type));

      Promise.all(creation_requests)
        .then(shaders => {
          shaderProgram = gl.createProgram();
          for (let shader of shaders)
            gl.attachShader(shaderProgram, shader);
          gl.linkProgram(shaderProgram);

          if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
          }

          gl.useProgram(shaderProgram);

          shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
          gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

          // Getting all uniform locations
          shaderProgram.resolutionLocation = gl.getUniformLocation(shaderProgram, 'resolution');
          shaderProgram.zoomLocation = gl.getUniformLocation(shaderProgram, 'zoom');
          shaderProgram.offsetLocation = gl.getUniformLocation(shaderProgram, 'offset');
          shaderProgram.iterationLocation = gl.getUniformLocation(shaderProgram, 'iterations');

          is_shader_loaded = true;
        });
    }

    function setMatrixUniforms() {
      gl.uniform2f(shaderProgram.resolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(shaderProgram.zoomLocation, fractalZoom);
      gl.uniform1i(shaderProgram.iterationLocation, iterationsCount);
      gl.uniform2f(shaderProgram.offsetLocation, mouseDragX, mouseDragY);
    }

    var squareVertexPositionBuffer;

    function initBuffers() {
      squareVertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      vertices = [
        1.0, 1.0, 0.0,
        -1.0, 1.0, 0.0,
        1.0, -1.0, 0.0,
        -1.0, -1.0, 0.0
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      squareVertexPositionBuffer.itemSize = 3;
      squareVertexPositionBuffer.numItems = 4;
    }

    function drawScene() {
      if (is_shader_loaded) {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
      }
    }

    function tick() {
      window.requestAnimationFrame(tick);
      drawScene();
    }

    function webGLStart() {
      canvas = document.getElementById("wegl-canvas");
      is_shader_loaded = false;
      initGL(canvas);
      initShaders();
      initBuffers();

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);

      mouseDragX = 0;
      mouseDragY = 0;
      fractalZoom = 1;
      iterationsCount = 12 * 12;

      drawScene();
      tick();
    }

    window.addEventListener('resize', CanvasResize, false);
    function CanvasResize(e) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight

      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
    }

    function MouseDragging(e) {
      if (mouseDragging) {
        mouseDragX += -0.008 * (e.clientX - oldMouseX) / fractalZoom;
        mouseDragY += 0.008 * (e.clientY - oldMouseY) / fractalZoom;
        oldMouseX = event.clientX; oldMouseY = event.clientY;
      }
    }

    function IterationsCountChange(e) {
      let iterations_changer = document.getElementById("iterations_changer");
      iterationsCount = iterations_changer.value;
    }
  </script>
</head>


<body onload="webGLStart();">
  <canvas id="wegl-canvas" style="background-color: #000000; width: 100%; height: calc(100% - 25px)" height="720"
    width="1240" onwheel="fractalZoom=Math.max(fractalZoom * (event.deltaY > 0 ? 1.25 : 0.8), 0.1);"
    onmousedown="mouseDragging=true;oldMouseX=event.clientX; oldMouseY=event.clientY" onmouseup="mouseDragging=false"
    onmousemove="MouseDragging(event);" onresize="CanvasResize(event);"></canvas>

  <lable style="margin-bottom: 10px;">Iterations Count: </lable><input id="iterations_changer" style="margin-top: 0px;"
    type="number" onchange="IterationsCountChange(event);">
</body>

</html>
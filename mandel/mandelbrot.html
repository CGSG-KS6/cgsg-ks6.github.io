<!DOCTYPE html>

<head>
  <meta charset="utf-8" />
  <title>Mandelbrot Fractal</title>
  <link rel="stylesheet" href="interface.css">

  <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
  <script type="text/javascript">
    /* Script data */
    let
      gl,
      canvas,
      squareVertexPositionBuffer,
      shaderProgram,
      fractalZoom,
      iterationsCount,
      mouseDragX,
      mouseDragY,
      isMouseDragging,
      oldMouseX,
      oldMouseY,
      fractalInsColor,
      fractalOutColor,
      backColor,
      fractalColorBlend;

    function hexToRgb(hex) {
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });

      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16) / 255.0,
        g: parseInt(result[2], 16) / 255.0,
        b: parseInt(result[3], 16) / 255.0
      } : null;
    }

    /***
     * Creation functions.
     ***/

    /* Shader creation function.
     * Arguments:
     *   - path to shader file:
     *       shaderPath;
     *   - shader file type ("vertex", "fragment"):
     *       shaderType;
     * Returns:
     *   (Promise) shader creation promise.
     */
    function createShader(shaderPath, shaderType) {
      return new Promise(function (resolve, reject) {
        let shd;

        window.fetch(shaderPath)
          .then((response) => {
            return response.text();
          })
          .then((file_text) => {
            if (shaderType == "fragment") shd = gl.createShader(gl.FRAGMENT_SHADER);
            else if (shaderType == "vertex") shd = gl.createShader(gl.VERTEX_SHADER);
            else reject(shd);

            gl.shaderSource(shd, file_text);
            gl.compileShader(shd);

            if (!gl.getShaderParameter(shd, gl.COMPILE_STATUS)) {
              alert(`Shader creation error.\n\nPath: ${shaderPath}. Type: ${shaderType}\n\nLog:\n` + gl.getShaderInfoLog(shd));
              reject(shd);
            }

            resolve(shd);
          });
      });
    }

    /* Shader programm creaion function.
     * Arguments:
     *   - array of shaders information (Path, Type):
     *       shadersInfoArray;
     * Returns:
     *   (WebGLProgram) shader programm id.  
     */
    function shaderProgramCreate(shadersInfoArray) {
      return new Promise(function (resolve, reject) {
        let creation_requests = shadersInfoArray.map(shader_info => createShader(shader_info.Path, shader_info.Type));
        let shader_prg;

        Promise.all(creation_requests)
          .then(shaders => {
            shader_prg = gl.createProgram();
            for (let shader of shaders)
              gl.attachShader(shader_prg, shader);
            gl.linkProgram(shader_prg);

            if (!gl.getProgramParameter(shader_prg, gl.LINK_STATUS)) {
              let error_str = "Shader program creation error.\n\nShader list:\n";
              for (let shader_info of shadersInfoArray)
                error_str += `Path: ${shader_info.Path}. Type: ${shader_info.Type}`;
              alert(error_str);
              reject(shader_prg);
            }

            resolve(shader_prg);
          });
      });
    }

    /* Setting location of all uniforms, verecies possition attribute.
     * Arguments: None.
     * Returns: None.
     */
    function uniformsInit() {
      gl.useProgram(shaderProgram);
      shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
      gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

      shaderProgram.resolutionLocation = gl.getUniformLocation(shaderProgram, 'resolution');
      shaderProgram.zoomLocation = gl.getUniformLocation(shaderProgram, 'zoom');
      shaderProgram.offsetLocation = gl.getUniformLocation(shaderProgram, 'offset');
      shaderProgram.iterationLocation = gl.getUniformLocation(shaderProgram, 'iterations');
      shaderProgram.fractalInsColorLocation = gl.getUniformLocation(shaderProgram, 'ins_col');
      shaderProgram.fractalOutColorLocation = gl.getUniformLocation(shaderProgram, 'out_col');
      shaderProgram.backColorLocation = gl.getUniformLocation(shaderProgram, 'back_col');
      shaderProgram.fractalColorBlendLocation = gl.getUniformLocation(shaderProgram, 'col_blend');
    }

    /* Creating vertex buffer and setting rectangle to its data function.
     * Arguments: None.
     * Returns: None.
     */
    function vertexBufferInit() {
      let vertices =
        [
          1.0, 1.0, 0.0,
          -1.0, 1.0, 0.0,
          1.0, -1.0, 0.0,
          -1.0, -1.0, 0.0
        ];

      squareVertexPositionBuffer = gl.createBuffer();
      squareVertexPositionBuffer.itemSize = 3;
      squareVertexPositionBuffer.numItems = 4;

      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    }

    /* WebGL initialisation function.
     * Arguments:
     *   - screen canvas to get context:
     *       canvas;
     * Returns: None.
     */
    function webGLInit(canvas) {
      /* Creating OpengGL handler */
      try {
        gl = canvas.getContext("experimental-webgl");
      } catch (e) {
      }
      if (!gl) {
        alert("Could not initialise WebGL");
      }
    }

    /* System initialisation function.
     * Arguments: None.
     * Returns: None.
     */
    function webGLStart() {
      cameraSetDefualt();
      iterationsCount = 12 * 12;
      fractalInsColor = hexToRgb("361111");
      fractalOutColor = hexToRgb("df4edf");
      backColor = hexToRgb("998a8a");
      fractalColorBlend = 6;

      canvas = document.getElementById("wegl-canvas");
      canvas.hidden = true;
      webGLInit(canvas);
      canvasResize();
      vertexBufferInit();
      shaderProgramCreate([{ Path: './shaders/vertex.glsl', Type: "vertex" }, { Path: './shaders/fragment.glsl', Type: "fragment" }])
        .then((shd_prg) => {
          canvas.hidden = false;
          shaderProgram = shd_prg;
          uniformsInit();

          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          gl.enable(gl.DEPTH_TEST);
          drawScene();
          tick();
        });
    }

    /***
     * Each frame functions.
     ***/

    /* Sending all uniforms to shader function.
     * Arguments: None.
     * Returns: None.
     */
    function uniformsSend() {
      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

      gl.uniform2f(shaderProgram.resolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(shaderProgram.zoomLocation, fractalZoom);
      gl.uniform1i(shaderProgram.iterationLocation, iterationsCount);
      gl.uniform2f(shaderProgram.offsetLocation, mouseDragX, mouseDragY);
      gl.uniform3f(shaderProgram.fractalInsColorLocation, fractalInsColor.r, fractalInsColor.g, fractalInsColor.b);
      gl.uniform3f(shaderProgram.fractalOutColorLocation, fractalOutColor.r, fractalOutColor.g, fractalOutColor.b);
      gl.uniform3f(shaderProgram.backColorLocation, backColor.r, backColor.g, backColor.b);
      gl.uniform1f(shaderProgram.fractalColorBlendLocation, fractalColorBlend);
    }

    /* Drawing scene function.
     * Arguments: None.
     * Returns: None.
     */
    function drawScene() {
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      uniformsSend();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
    }

    /* Drawing scene call function.
     * Arguments: None.
     * Returns: None.
     */
    function tick() {
      window.requestAnimationFrame(tick);
      drawScene();
    }

    /***
     * Events handle functions
     ***/

    window.addEventListener('resize', canvasResize, false);

    /* Setting viewer to default possition function.
     * Arguments: None.
     * Returns: None.
     */
    function cameraSetDefualt() {
      mouseDragX = 0;
      mouseDragY = 0;
      fractalZoom = 1;
    }

    /* Canvas resize function.
     *   - event handle:
     *      e;
     * Returns: None.
     */
    function canvasResize(e) {
      canvas.width = window.innerWidth * 0.8;
      canvas.height = window.innerHeight;

      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
    }

    /* Mouse dragging function. 
     *   - event handle:
     *      e;
     * Returns: None.
     */
    function mouseDragging(e) {
      if (isMouseDragging) {
        mouseDragX += -0.008 * (e.clientX - oldMouseX) / fractalZoom;
        mouseDragY += 0.008 * (e.clientY - oldMouseY) / fractalZoom;
        oldMouseX = event.clientX; oldMouseY = event.clientY;
      }
    }
  </script>
</head>


<body onload="webGLStart();">
  <canvas id="wegl-canvas" style="position: fixed; top: 0px; right: 0px; border: 0px; width: 80%; height: 100%;"
    onwheel="fractalZoom=Math.max(fractalZoom * (event.deltaY > 0 ? 1.25 : 0.8), 0.1);"
    onmousedown="isMouseDragging=true;oldMouseX=event.clientX; oldMouseY=event.clientY"
    onmouseup="isMouseDragging=false" onmousemove="mouseDragging(event);" onresize="canvasResize(event);"></canvas>

  <div>
    <a class="title" style="font-size: 25px;">Fractal Settings</a>
  </div>

  <div>
    <lable class="text" style="position: sticky; width: 20%;">Iterations Count: </lable>
    <input id="iterations_changer" class="input" value="144" type="number" onchange="iterationsCount=this.value;"
      style="width: 75px;">
  </div>

  <div>
    <label id="fractalZoomLabel" class="text" style="position: sticky; width: 20%;">Fractal Zoom: </label>
    <input id="zoom_changer" class="input" value="1" type="number" onchange="fractalZoom=this.value;"
      style="width: 75px;">
  </div>

  <div>
    <label class="text" style="position: sticky; width: 20%;">Fractal Insight Color: </label>
    <input type="color" value="#361111" onchange="fractalInsColor=hexToRgb(this.value.split('#').join(''));">
  </div>
  <div>
    <label class="text" style="position: sticky; width: 20%;">Fractal Outsight Color: </label>
    <input type="color" value="#df4edf" onchange="fractalOutColor=hexToRgb(this.value.split('#').join(''));">
  </div>
  <div>
    <label class="text" style="position: sticky; width: 20%;">Background Color: </label>
    <input type="color" value="#998a8a" onchange="backColor=hexToRgb(this.value.split('#').join(''));">
  </div>

  <div>
    <label class="text" style="position: sticky; width: 20%;">Blending: </label>
    <input type="range" value="6" min="0.5" max="20" onchange="fractalColorBlend=this.value">
  </div>

  <div>
    <button class="button button5" onclick="cameraSetDefualt();"
      style="position: sticky; width: calc(20% - 15px); height: 65px;">Set Default Camera Location</button>
  </div>

  <label style="position: fixed; bottom: 100px; left: calc(10% - 75px); font-size: 20px;">CGSG FOREVER!!!</label>
  <img style="position: fixed; bottom: 0px; left: calc(10% - 69px);" src="../images/cgsg100.png">
</body>

</html>